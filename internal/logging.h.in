/**
 * \file logging.h
 *
 * Created on: Oct 27, 2016
 * \author: Jeremie Deray
 */

#ifndef _@PROJECT_NAME_CAPS@_INTERNAL_CONFIG_LOGGING_H_
#define _@PROJECT_NAME_CAPS@_INTERNAL_CONFIG_LOGGING_H_

#cmakedefine _LSPDLOG_COMPILER_SUPPORTS_CONSTEXPR_FUNC_

#include "wrapper.h"

namespace
{

// macro trick from https://blog.galowicz.de/2016/02/20/short_file_macro/
using cstr = const char * const;

static constexpr cstr past_last_slash(cstr str, cstr last_slash)
{
  return *str == '\0' ? last_slash :
         *str == '/'  ? past_last_slash(str + 1, str + 1) :
                        past_last_slash(str + 1, last_slash);
}

static constexpr cstr past_last_slash(cstr str)
{
  return past_last_slash(str, str);
}

#define __SHORT_FILE__ ({constexpr cstr sf__ {past_last_slash(__FILE__)}; sf__;})

/**
 * \brief A (thread-safer ?) Singleton implementation
 * with constructor argument forwarding.
 **/
template <class T>
class Singleton
{

  using SingletonOPtr = std::unique_ptr<T>;

public:

  template <typename... Args>
  static T& get(Args&&... args)
  {
    static SingletonOPtr instance_(new T(std::forward<Args>(args)...));
    return *instance_;
  }

  constexpr Singleton(const Singleton&)       = delete;
  //constexpr Singleton(const Singleton&&)      = delete;

  constexpr Singleton& operator=(const Singleton&)  = delete;
  //constexpr Singleton& operator=(const Singleton&&) = delete;

protected:

  Singleton()  = default;
  ~Singleton() = default;
};

#ifdef _LSPDLOG_COMPILER_SUPPORTS_CONSTEXPR_FUNC_
constexpr auto repeated_brace = std::make_tuple("{}",
#else
    const auto repeated_brace = std::make_tuple("{}",
#endif
                                                "{}{}",
                                                "{}{}{}",
                                                "{}{}{}{}",
                                                "{}{}{}{}{}",
                                                "{}{}{}{}{}{}",
                                                "{}{}{}{}{}{}{}",
                                                "{}{}{}{}{}{}{}{}",
                                                "{}{}{}{}{}{}{}{}{}",
                                                "{}{}{}{}{}{}{}{}{}{}",
                                                "{}{}{}{}{}{}{}{}{}{}{}",
                                                "{}{}{}{}{}{}{}{}{}{}{}{}",
                                                "{}{}{}{}{}{}{}{}{}{}{}{}{}",
                                                "{}{}{}{}{}{}{}{}{}{}{}{}{}{}",
                                                "{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}",
                                                "{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}",
                                                "{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}",
                                                "{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}",
                                                "{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}",
                                                "{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}",
                                                "{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}",
                                                "{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}",
                                                "{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}",
                                                "{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}",
                                                "{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}"); // up to 25 args. Should be fine

class Logger
{
public:

  Logger();
  ~Logger();

  Logger(Logger&)         = delete;
  void operator=(Logger&) = delete;

  template<typename... Args>
  void info(Args&&... args);

  template<typename... Args>
  void warn(Args&&... args);

  template<typename... Args>
  void error(Args&&... args);

  template<typename... Args>
  void critical(Args&&... args);

  template<typename... Args>
  void debug(Args&&... args);

  template<typename... Args>
  void trace(Args&&... args);

  /*constexpr*/ // bool async_enabled() const noexcept;

  /*constexpr*/ bool debug_enabled() const noexcept;

  /*constexpr*/ bool trace_enabled() const noexcept;

  // bool set_async_queue(const std::size_t q_size);

protected:

  std::shared_ptr<spdlog::logger> console_;
};

Logger::Logger()
{
  console_ = spdlog::stdout_color_mt("@PROJECT_NAME@_main_console");

#if ${_LSPDLOG_ENABLE_TRACE_LOGGING_}
  console_->set_level(spdlog::level::trace);
#endif

// #if ${_LSPDLOG_ENABLE_ASYNC_LOGGING_}
//   // Enable asynchronous logging
//   // Queue size must be a power of 2
//   spdlog::set_async_mode(4096);
// 
//   // Logging pattern is :
//   // [hour:minutes:seconds.nanoseconds][thread-id] #log-content
//   spdlog::set_pattern("[%t][%H:%M:%S.%F][%l] %v");
// #else

  // Logging pattern is :
  // [logging-type] #log-content
  spdlog::set_pattern("[%Y-%m-%d %T.%F] [%=10l] %v");
// #endif
}

Logger::~Logger()
{
  spdlog::drop("@PROJECT_NAME@_main_console");
}

template<typename... Args>
void Logger::info(Args&&... args)
{
  console_->info(std::get<sizeof...(args)>(repeated_brace), "[@PROJECT_NAME@] ",
                 std::forward<Args>(args)...);
}

template<typename... Args>
void Logger::warn(Args&&... args)
{
  console_->warn(std::get<sizeof...(args)>(repeated_brace), "[@PROJECT_NAME@] ",
                 std::forward<Args>(args)...);
}

template<typename... Args>
void Logger::error(Args&&... args)
{
  console_->error(std::get<sizeof...(args)>(repeated_brace), "[@PROJECT_NAME@] ",
                  std::forward<Args>(args)...);
}

template<typename... Args>
void Logger::critical(Args&&... args)
{
  console_->critical(std::get<sizeof...(args)>(repeated_brace), "[@PROJECT_NAME@] ",
                     std::forward<Args>(args)...);
}

template<typename... Args>
void Logger::debug(Args&&... args)
{
  console_->debug(std::get<sizeof...(args)>(repeated_brace), "[@PROJECT_NAME@] ",
                  std::forward<Args>(args)...);
}

template<typename... Args>
void Logger::trace(Args&&... args)
{
  console_->trace(std::get<sizeof...(args)>(repeated_brace), "[@PROJECT_NAME@] ",
                  std::forward<Args>(args)...);
}

inline /*constexpr*/ bool Logger::debug_enabled() const noexcept
{
  return ${_LSPDLOG_ENABLE_DEBUG_};
}

inline /*constexpr*/ bool Logger::trace_enabled() const noexcept
{
  return ${_LSPDLOG_ENABLE_TRACE_LOGGING_};
}

// inline /*constexpr*/ bool Logger::async_enabled() const noexcept
// {
//   return ${_LSPDLOG_ENABLE_ASYNC_LOGGING_};
// }

// inline bool Logger::set_async_queue(const std::size_t q_size)
// {
// #if ${_LSPDLOG_ENABLE_ASYNC_LOGGING_}
//   bool p2 = q_size%2 == 0;
//   if (p2) spdlog::set_async_mode(q_size);
//   else error("Can not set async queue to ", q_size, " as it's not a power of 2!");
//   return p2;
// #else
//   return false;
// #endif
// }

} /* namespace */

namespace lspdlog
{
namespace details
{
using Lspdlogger = Singleton<Logger>;
} /* namespace details */

#define @PROJECT_NAME_CAPS@_INFO(...) \
  lspdlog::details::Lspdlogger::get().info(__VA_ARGS__);

#define @PROJECT_NAME_CAPS@_WARN(...) \
  lspdlog::details::Lspdlogger::get().warn(__VA_ARGS__);

#define @PROJECT_NAME_CAPS@_ERROR(...) \
  lspdlog::details::Lspdlogger::get().error(__VA_ARGS__);

#define @PROJECT_NAME_CAPS@_CRITICAL(...) \
  lspdlog::details::Lspdlogger::get().critical(__VA_ARGS__);

#if ${_LSPDLOG_ENABLE_DEBUG_}
  #define @PROJECT_NAME_CAPS@_DEBUG(...) \
    lspdlog::details::Lspdlogger::get().debug(__VA_ARGS__);
#else
  #define @PROJECT_NAME_CAPS@_DEBUG(...)
#endif

#if ${_LSPDLOG_ENABLE_TRACE_LOGGING_}
  #define @PROJECT_NAME_CAPS@_TRACE(...) \
    {char this_file[] = __FILE__;\
    lspdlog::details::Lspdlogger::get().trace("[", basename(this_file), ", ln.", __LINE__, \
              " : ", __FUNCTION__, "()] ", __VA_ARGS__);}
#else
  #define @PROJECT_NAME_CAPS@_TRACE(...)
#endif

} // namespace lspdlog

#endif  /* _@PROJECT_NAME_CAPS@_INTERNAL_CONFIG_LOGGING_H_ */
