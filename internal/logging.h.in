/**
 * \file logging.h
 *
 * Created on: Oct 27, 2016
 * \author: Jeremie Deray
 */

#ifndef INTERNAL_CONFIG_LOGGING_H_
#define INTERNAL_CONFIG_LOGGING_H_

#include "spdlog/spdlog.h"

namespace lspdlog
{
namespace details
{

/**
 * \brief A (thread-safer ?) Singleton implementation
 * with constructor argument forwarding.
 **/
template <class T>
class Singleton
{
  /**
   * \brief Custom deleter to by-pass private destructor issue.
   **/
  struct Deleter;

  using SingletonOPtr = std::unique_ptr<T, Deleter>;

  public:

  template <typename... Args>
  static T& get(Args&&... args)
  {
    static SingletonOPtr instance_(new T(args...));
    return *instance_;
  }

  constexpr Singleton(const Singleton&)       = delete;
  //constexpr Singleton(const Singleton&&)      = delete;

  constexpr Singleton& operator=(const Singleton&)  = delete;
  //constexpr Singleton& operator=(const Singleton&&) = delete;

protected:

  Singleton() = default;

  virtual ~Singleton() = default;
};

template <class T>
struct Singleton<T>::Deleter
{
  void operator()( const T* const p )
  {
    delete p;
  }
};

class Logger : public Singleton<Logger>
{
  friend class Singleton<Logger>;

protected:

  Logger();
  ~Logger();

public:

  Logger(Logger&)         = delete;
  void operator=(Logger&) = delete;

  template<typename... Args>
  void info(const Args&... args);

  template<typename... Args>
  void warn(const Args&... args);

  template<typename... Args>
  void error(const Args&... args);

  template<typename... Args>
  void debug(const Args&... args);

  void enable_debug(const bool enable);

  bool enable_debug();

protected:

  std::shared_ptr<spdlog::logger> console_;

  std::string repeat_string(const std::string &str, std::size_t n)
  {
    if (n == 0) return {};

    if (n == 1 || str.empty()) return str;

    const auto n_char = str.size();

    if (n_char == 1) return std::string(n, str[0]);

    std::string res(str);
    res.reserve(n_char * n);

    std::size_t m = 2;
    for (; m <= n; m *= 2) res += res;

    n -= m*.5;

    res.append(res.c_str(), n * n_char);

    return res;
  }
};

Logger::Logger()
{
  console_ = spdlog::stdout_color_mt("@PROJECT_NAME@_main_console");

  spdlog::set_pattern("[%l] %v");

  enable_debug(${__AM_I_COMPILED_IN_DEBUG__});
}

Logger::~Logger()
{
  spdlog::drop_all();
}

template<typename... Args>
void Logger::info(const Args&... args)
{
  console_->info(repeat_string("{}", sizeof...(args)).c_str(), args...);
}

template<typename... Args>
void Logger::warn(const Args&... args)
{
  console_->warn(repeat_string("{}", sizeof...(args)).c_str(), args...);
}

template<typename... Args>
void Logger::error(const Args&... args)
{
  console_->error(repeat_string("{}", sizeof...(args)).c_str(), args...);
}

template<typename... Args>
void Logger::debug(const Args&... args)
{
  console_->debug(repeat_string("{}", sizeof...(args)).c_str(), args...);
}

inline void Logger::enable_debug(const bool enable)
{
  (enable)? console_->set_level(spdlog::level::debug) :
            console_->set_level(spdlog::level::info);
}

inline bool Logger::enable_debug()
{
  return console_->level() == spdlog::level::debug;
}

#define @PROJECT_NAME_CAPS@_INFO(...) \
  lspdlog::details::Logger::get().info(__VA_ARGS__);

#define @PROJECT_NAME_CAPS@_WARN(...) \
  lspdlog::details::Logger::get().warn(__VA_ARGS__);

#define @PROJECT_NAME_CAPS@_ERROR(...) \
  lspdlog::details::Logger::get().error(__VA_ARGS__);

#define @PROJECT_NAME_CAPS@_DEBUG(...) \
  lspdlog::details::Logger::get().debug(__VA_ARGS__);

#define @PROJECT_NAME_CAPS@_ENABLE_DEBUG_LOG() \
  lspdlog::details::Logger::get().enable_debug(true);

#define @PROJECT_NAME_CAPS@_DISABLE_DEBUG_LOG() \
  lspdlog::details::Logger::get().enable_debug(false);

} // namespace details
} // namespace lspdlog

#endif  /* INTERNAL_CONFIG_LOGGING_H_ */
